from os import TextFile

@enum
class Op:
    Inp
    Add
    Mul
    Div
    Mod
    Eql

class Instruction:
    op: Op
    v1: char
    v2_1: char
    v2_2: i64

def get_input(filename: string) -> [[Instruction]]:
    instruction_groups: [[Instruction]] = []
    instructions: [Instruction] = None

    for line in TextFile(f"{__assets__}/day_24/{filename}").read().strip().split("\n"):
        parts = line.split(' ')

        match parts[0]:
            case "inp":
                op = Op.Inp
            case "add":
                op = Op.Add
            case "mul":
                op = Op.Mul
            case "div":
                op = Op.Div
            case "mod":
                op = Op.Mod
            case "eql":
                op = Op.Eql

        if len(parts) == 2:
            instruction = Instruction(op, parts[1][0], '', 0)
        else:
            if parts[2][0] in "wxyz":
                instruction = Instruction(op, parts[1][0], parts[2][0], 0)
            else:
                instruction = Instruction(op, parts[1][0], '', i64(parts[2]))

        if instruction.op == Op.Inp:
            if instructions is not None:
                instruction_groups.append(instructions)

            instructions = []

        instructions.append(instruction)

    instruction_groups.append(instructions)

    return instruction_groups

def get(v_1: char, v_2: i64, w: i64, x: i64, y: i64, z: i64) -> i64:
    match v_1:
        case 'w':
            b = w
        case 'x':
            b = x
        case 'y':
            b = y
        case 'z':
            b = z
        case _:
            b = v_2

    return b

def run(z: i64, instructions: [Instruction], input: i64) -> i64:
    w = 0
    x = 0
    y = 0

    for instruction in instructions:
        match instruction.op:
            case Op.Inp:
                w = input
            case Op.Add:
                b = get(instruction.v2_1, instruction.v2_2, w, x, y, z)

                match instruction.v1:
                    case 'w':
                        w += b
                    case 'x':
                        x += b
                    case 'y':
                        y += b
                    case 'z':
                        z += b
            case Op.Mul:
                b = get(instruction.v2_1, instruction.v2_2, w, x, y, z)

                match instruction.v1:
                    case 'w':
                        w *= b
                    case 'x':
                        x *= b
                    case 'y':
                        y *= b
                    case 'z':
                        z *= b
            case Op.Div:
                b = get(instruction.v2_1, instruction.v2_2, w, x, y, z)

                match instruction.v1:
                    case 'w':
                        w /= b
                    case 'x':
                        x /= b
                    case 'y':
                        y /= b
                    case 'z':
                        z /= b
            case Op.Mod:
                b = get(instruction.v2_1, instruction.v2_2, w, x, y, z)

                match instruction.v1:
                    case 'w':
                        w %= b
                    case 'x':
                        x %= b
                    case 'y':
                        y %= b
                    case 'z':
                        z %= b
            case Op.Eql:
                b = get(instruction.v2_1, instruction.v2_2, w, x, y, z)

                match instruction.v1:
                    case 'w':
                        w = 1 if w == b else 0
                    case 'x':
                        x = 1 if x == b else 0
                    case 'y':
                        y = 1 if y == b else 0
                    case 'z':
                        z = 1 if z == b else 0
            case _:
                raise UnreachableError("Bad instruction.")

    return z

@trait
class Algoritm:

    def compare(self, model_number_1: i64, model_number_2: i64) -> i64:
        pass

    def result(self, model_numbers: [i64]) -> i64:
        pass

class Minimum(Algoritm):

    def compare(self, model_number_1: i64, model_number_2: i64) -> i64:
        return min(model_number_1, model_number_2)

    def result(self, model_numbers: [i64]) -> i64:
        return min(model_numbers)

class Maximum(Algoritm):

    def compare(self, model_number_1: i64, model_number_2: i64) -> i64:
        return max(model_number_1, model_number_2)

    def result(self, model_numbers: [i64]) -> i64:
        return max(model_numbers)

def both_parts(filename: string, algoritm: Algoritm) -> i64:
    instruction_groups = get_input(filename)
    states_in = {0: 0}
    states_out: {i64: i64} = {}

    for instruction_group in instruction_groups:
        for digit in range(1, 10):
            for z, model_number in states_in:
                z = run(z, instruction_group, digit)
                model_number = model_number * 10 + digit
                states_out[z] = algoritm.compare(model_number,
                                                 states_out.get(z, model_number))

        states_in = states_out
        states_out = {}

    return algoritm.result([model_number for z, model_number in states_in if z == 0])

def part_1(filename: string) -> i64:
    return both_parts(filename, Maximum())

def part_2(filename: string) -> i64:
    return both_parts(filename, Minimum())

def day_24():
    print(part_1("input.txt"))
    print(part_2("input.txt"))
